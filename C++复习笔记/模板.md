# 模板

对于一个空的类, C++会默默地做些什么

​`class Empty{};`

```c++
class Empty {
	Empty();
	Empty(const Empty&);
	Empty(Empty&&);
	~Empty();
	Empty& operator=(const Empty&);
	Empty& operator=(Empty&&);
	Empty *operator&();  // 取地址操作符, 将void* 转换为Empty*
	const Empty* operator&() const;
}
```

## 模板 template

源代码的复用机制

参数化模块

- 对程序模块(如类, 函数)加上类型参数
- 对不同类型的数据实施相同的操作

多态的一种形式, 类属多态

### 类属函数

同一函数对不同类型的数据完成相同的操作

在模板之前是使用宏来实现

- 缺陷是没有类型检查, 若类型不匹配则报错
- 只能实现简单的功能(一般人来说)

使用函数重载实现

- 缺陷是定义的重载函数太多
- 且很难定义全

使用函数指针实现

- 缺陷是需要定义额外参数
- 大量的指针运算
- 实现起来复杂
- 可读性差

模板引入的目标

- 完全: 确保能将需要的函数定义完全
- 清晰: 代码是清晰可读的

引入类型参数的概念, 一般写为`T`, 就是一个参数名

参数需要声明, 就像函数参数的声明那样

```c++
template <typename T>
```

​`typename`​和`class`​这里是一样的, 建议都使用`typename` c++98

函数模板是不会直接编译为二进制码的, 这里的T大小不明, 需要确定类型才能被编译

每到一个新的调用点, 编译器会把调用的类型填入, 然后进行编译

- 是形式上的代码复用
- 编译系统自动实例化函数模板, 发生在**调用时**

函数模板的类型参数声明中, 还可以带普通参数, 必须放在类型参数之后

```c++
template <class T, int size>
```

这个普通参数在编译时就被确定了, 而非像函数参数那样运行时确定, 相当于编译器常量

### 万能引用, 完美转发

引用折叠

- 规则非常简单：

  |组合|折叠结果|解释|
  | ------| ----------| --------------------------------|
  |​`T& &`|​`T&`|左值引用的左值引用 → 左值引用|
  |​`T& &&`|​`T&`|左值引用的右值引用 → 左值引用|
  |​`T&& &`|​`T&`|右值引用的左值引用 → 左值引用|
  |​`T&& &&`|​`T&&`|右值引用的右值引用 → 右值引用|

  **记忆口诀**：只要出现一个 `&`​（左值引用），结果就是 `&`​；只有全是 `&&`​ 时才保持 `&&`。

注意`int & & a = 10;`​ 是语法错误, 正确的右值引用是`int && a = 10;`

- CPP中没有引用的引用, 这也是为什么需要引用折叠规则

```cpp
#include <iostream>
using namespace std;

template<typename T>
void func(T&& param) {  // 注意：这里是万能引用，不是右值引用！
    // T 的类型会根据实参推导，可能产生引用折叠
}

int main() {
    int x = 10;
    const int cx = 20;
    
    func(x);   // x 是左值，T 推导为 int&，函数签名：void func(int& &&)
               // 引用折叠：int& && → int&
    
    func(cx);  // cx 是 const 左值，T 推导为 const int&
               // 函数签名：void func(const int& &&)
               // 引用折叠：const int& && → const int&
    
    func(10);  // 10 是右值，T 推导为 int，函数签名：void func(int&&)
               // 没有引用折叠
}
```

所以`T&&`是万能引用

- 不管是左值还是右值, 常量还是非常量都能接收
- 而`int&& arg`是右值引用, 注意区分

完美转发

- 引用折叠是 `std::forward` 能够实现完美转发的关键
- 如果T推导出来是左值, 就转发左值
- 如果推导出来是右值, 就转发右值

```c++
#include <iostream>
#include <utility>
using namespace std;

template<typename T>
void wrapper(T&& arg) {
    // 完美转发给另一个函数
    worker(std::forward<T>(arg));
}

void worker(int& x) {
    cout << "左值版本: " << x << endl;
}

void worker(int&& x) {
    cout << "右值版本: " << x << endl;
}

int main() {
    int x = 10;
    
    wrapper(x);   // 调用 worker(int&)
    wrapper(20);  // 调用 worker(int&&)
    
    return 0;
}

// 当 wrapper(x) 被调用时：
// T 推导为 int&
// std::forward<int&>(arg) 展开为：
// static_cast<int& &&>(arg) → static_cast<int&>(arg)
// 所以调用 worker(int&)

// 当 wrapper(20) 被调用时：
// T 推导为 int
// std::forward<int>(arg) 展开为：
// static_cast<int &&>(arg) → static_cast<int&&>(arg)
// 所以调用 worker(int&&)
```

### 模板的显式具体化

针对特定类型的处理

必须先有通用的模板才能显式具体化: 是一种函数特化

- 给出特定情况下的实现
- 以实现特定情况正确的效果, 和对特定情况进行性能优化

```c++
template<>
bool isEqual<const char*>(const char*a, const char*b) {
	return std::strcmp(a, b) == 0;
}
```

### 类属类

```c++
template <typename T>
class Stack {

};

Stack<int> S1; // 显式模板实参指定
```

C++17引入了类模板参数推导CTAD, 如`std::vector v = {1, 2, 3};`

类模板中的静态成员属于实例化后的类, 而非通用的带有模板参数的类

如果在模块A中要使用模块B中定义的某模板的实例, 而在模块B中未使用这个实例, 则模块A无法使用这个实例

可以通过将模板定义完整放入头文件来解决

C++中的模板定义都是完整放入头文件的

- 如何解决重复定义
- C++的机制, 凡是出现模板定义, 都按照`inline`处理, 自动解决重复声明的问题
- 所以可以放心地放入头文件中

### 模板的实例化

模板是一种源代码复用机制

- 实例化: 生成具体的函数/类
- 函数模板的实例化

  - 隐式实现
  - 根据具体模板函数调用, 由传入的参数决定
- 类模板的实例化

  - 创建对象时显式指定, 或者CPP17后的类模板参数推导CTAD

是否实例化模板的某个实例由使用点来决定: 如果未使用到一个模板的某个实例, 则编译系统不会生成相应实例的代码

### if constexpr

编译器会根据实例化的类型, 直接删除其他类型不符合的分支

- 因为模板函数的实例化发生在调用点，编译的时候确定
- ​`constexpr`也在编译的时候计算
- 计算出不可达分支编译器直接删除

```c++
template <typename T>
std::string autoToStrping(T val) {
	if constexpr(std::is_same_v<T, std::string) {
		return val;
	} else {
		return std::to_string(val);
	}
}
```

选择性编译

### 模板元编程

不用运行即可计算Fib数, 值存在代码里, 而非内存中

是图灵完备的, 可以直接生成程序

```cpp
#include <iostream>

template<int N>
class Fib{
public:
    enum {value = Fib<N-1>::value + Fib<N-2>::value};
};

template<>
class Fib<0> {
public:
    enum {value = 1};
};

template<>
class Fib<1>{
public:
    enum {value = 1};
};

int main() {
    std::cout << Fib<8>::value << std::endl;
}
```

### 编译器类型推导

C++11 的`auto`

- 是一个占位符
- 根据=右边的值自动把`auto`替换成正确的类型
- ​`auto`变量必须初始化, 不然无法进行类型替换

简化代码的书写

- 特别是泛型编程
- STL容器

默认情况下, auto推导出的类型是值拷贝, 会丢弃引用和const限定符

- 不会忽略底层的`const`​ 如字符串推导为`const char *`

- 如果需要, 自己加上

```cpp
int main() {
	std::vector<int> vec = {1, 2, 3, 4, 5};
	for (auto v : vec) {
		v = v * 2; // 无效修改, 因为获取的是值的拷贝
	}

	for (auto& v : vec) {
		v = v * 2; // 内容变为 {2, 4, 6, 8, 10}
	}
}
```

## 异常处理

异常

- 可以预见
- 但无法避免

异常处理用于提高程序的鲁棒性

发现异常之处与处理异常之处往往不一致

常见的处理方法

- 函数参数(引用参数)或返回值
- 逐层返回来告知异常
- 缺陷: 程序结构不清楚

C++的异常处理机制: 一种专门, 清晰描述异常处理过程的机制

- try: 监控
- throw: 抛异常对象(表达式) **按值拷贝**, 从一个作用域抛走
- catch: 捕获并处理 **按引用catch**, 已经传到这个作用域了
- 一个`try`​语句块的后面可以跟多个`catch`语句块, 用于捕获不同类型的异常进行处理

若异常一直没被捕获, 则系统会触发`abort`来处理

注意catch块排列顺序

- 先子类再基类
- 因为捕获是按照引用`catch`的
- 若先`catch`基类则子类全部都在基类处被捕获

​`catch(...)` 默认异常处理

无参数`throw`

- 将捕获到的异常对象重新抛出

```cpp
catch(int) {
	throw;
}
```

## I/O 处理

操作符`<<`​ 和 `>>` 的重载

全局函数是没有多态性的, 无法动态绑定

但这个操作符又只能作为全局函数重载

```cpp
#include <iostream>
using namespace std;
class CPoint2D {
protected:
    double x, y;
public:
    CPoint2D(double x, double y): x(x), y(y){}
    friend ostream& operator <<(ostream&,CPoint2D&);
};

ostream& operator << (ostream& out, CPoint2D& a) {
    out << a.x << "," << a.y << endl;
    return out;
}

class CPoint3D: public CPoint2D{
    double z;
public:
    CPoint3D(double x, double y, double z) : CPoint2D(x, y), z(z){}
    friend ostream& operator <<(ostream&, CPoint3D&);
};

ostream& operator << (ostream& out, CPoint3D& a) {
    out << a.x << "," << a.y << "," << a.z << endl;
    return out;
}

int main() {
    CPoint3D b(1, 2, 3);
    cout << b;	// 1, 2, 3
    CPoint2D& base = b;
    cout << base; // 1, 2 静态绑定到CPoint2D的重载函数上, 因为该友元函数无法声明为虚函数
}
```

**需要虚化非成员函数**

NVI: 在非虚接口中调用虚函数

```cpp
class CPoint2D {
	...
	virtual void display(ostream& out) {
        out << *this;
    }
}

class CPoint3D: public CPoint2D{
	...
	void display(ostream& out) override{
        out << *this;
    }
}
```

## 虚构造器

实现一个虚函数

- 在虚函数中调用构造方法

```cpp
virtual NLComponent* clone() const =0;

virtual TextBlock* clone() const {
	return new TextBlock(*this);
}

virtual Graphic* clone() const {
	return new Graphic(*this);
}
```

## 数组的多态

不要使用数组来进行多态编程, 使用`vector`

- 当数组直接存储对象的时候, 存在对象切片问题

```cpp
Animal animalArray[3];
Dog dog;
Cat cat;

animalArray[0] = Animal();  // 正常
animalArray[1] = dog;       // 发生对象切片！
animalArray[2] = cat;       // 发生对象切片！

// 数组中的每个元素都是 Animal 大小
// Dog 和 Cat 中特有的数据被切掉了！
// sizeof(Animal) != sizeof(Dog) != sizeof(Cat)

cout << "Size of Animal: " << sizeof(Animal) << endl;
cout << "Size of Dog: " << sizeof(Dog) << endl;
cout << "Size of Cat: " << sizeof(Cat) << endl;

Animal* ptr = animalArray[0];
for (int i = 0; i < 3; ++i) {
    ptr->speak();
    ++ptr;  // 危险！ptr 增加 sizeof(Animal)，但实际可能是 Dog/Cat
    // 如果 Dog/Cat 的大小与 Animal 不同，这就错位了！
}
```

## 考试题型

三个部分

1. 理解性解答题
2. 读程序写答案
3. 手搓代码
