# 继承和多态

## 单继承

继承机制

- 基于目标代码的复用
- 对事物进行分类

  - 派生类是基类的具体化
  - 把事物（概念）以层次结构表示出来，有利于描述和解决问题
- 增量开发

protected: 派生类可以访问基类的protected成员

但是派生类的对象，是无法访问该对象中的基类对象的protected成员

- 取决于内存在谁那里
- 派生类中拥有一个基类的内存
- 但基类对象的成员是在基类对象的内存中

派生类无法访问基类的private成员，但并不代表不能用

**将派生类看作基类的一个成员来理解**

### 名掩盖

派生类如果重载了基类的成员方法，则派生类无法再调用到原来基类的成员方法（区别于Java的重写）

C++的函数调用是全局函数的匹配方式 **名掩盖的本质**

- 先匹配名称

  - 先在带有类的名空间，若在当前名空间中无法找到，就去基类的名空间找，一旦找到就开始参数匹配
- 再匹配参数
- 若参数匹配不上则报错
- 因为先匹配上了名字，此时参数不匹配，并不会回头再去找其他函数

在C++中尽量避免定义**与基类同名但参数不同**的成员方法，对于需要重写的方法，在基类中用`virtual`​关键字标注, 在子类中用`override`关键字标注

### 在派生类中引入基类的成员

如果必须同名不同参数, 使用`using`关键字

```cpp
class Collection {
public:
    virtual void add(int value) {
        std::cout << "Adding int: " << value << std::endl;
    }
    
    virtual void add(double value) {
        std::cout << "Adding double: " << value << std::endl;
    }
};

class SmartCollection : public Collection {
public:
    // 引入基类的所有 add 重载
    using Collection::add;
    
    // ✅ 添加新的重载，不会掩盖基类的
    void add(const std::string& value) {
        std::cout << "Adding string: " << value << std::endl;
    }
    
    // ✅ 也可以重写基类的虚函数
    void add(int value) override {
        std::cout << "Smart adding int: " << value << std::endl;
    }
};

int main() {
    SmartCollection sc;
    sc.add(10);       // ✅ 调用 SmartCollection::add(int)
    sc.add(3.14);     // ✅ 调用 Collection::add(double)
    sc.add("hello");  // ✅ 调用 SmartCollection::add(string)
    return 0;
}
```

使用`using`关键字

```c++
class Student {
public:
	char nickname[5];
}

class Undergrade_Student:public Student {
private:
	using Student::nickname;
}
```

在`Undergraduate_Student`​中降级了`nickname`​从`public`​降级为`private`

### 继承方式

- public: 默认的继承方式, 但如果不写这个, 反而是private, 所以要记得写上
- private: 基类中原来是public的, 都变为private, 不会影响该派生类, 但影响的是派生类的派生 表示"用...实现" 的关系, 类似组合
- protect: 基类中原来是public的, 都变为protect

```cpp
#include <iostream>

class Base {
public:
    void public_func() { std::cout << "Base::public_func" << std::endl; }
protected:
    void protected_func() { std::cout << "Base::protected_func" << std::endl; }
private:
    void private_func() { std::cout << "Base::private_func" << std::endl; }
};

// private 继承
class DerivedPrivate : private Base {
public:
    void test() {
        public_func();      // ✅ 在 DerivedPrivate 内部可以访问（现在是 private）
        protected_func();   // ✅ 在 DerivedPrivate 内部可以访问（现在是 private）
        // private_func();  // ❌ 仍然不可访问
    }
};

// 进一步派生
class FurtherDerived : public DerivedPrivate {
public:
    void further_test() {
        // public_func();    // ❌ 不可访问！因为 DerivedPrivate 将其变为 private
        // protected_func(); // ❌ 不可访问！因为 DerivedPrivate 将其变为 private
        
        // 只能通过 DerivedPrivate 的 public 接口
        test();  // ✅ 可以调用
    }
};

int main() {
    DerivedPrivate d;
    d.test();           // ✅
    // d.public_func(); // ❌ 错误：在外部不可访问（现在是 private）
    
    FurtherDerived fd;
    fd.further_test();  // ✅
    
    return 0;
}
```

什么是`protected`:

- 表示一个成员是**继承体系内部**共享

  - ​**类内部**：类的成员函数可以访问
  - ​**派生类内部**：派生类的成员函数可以访问
  - **类的对象**：不能直接访问
  - ​**友元类和友元函数**：可以访问

### 前向声明

前向声明只需声明名称, 不需要继承关系

### 继承的初始化

派生类对象的初始化

- 由基类和派生类共同完成

基类构造函数的调用

- 默认执行基类的默认构造函数
- 若要执行非默认构造函数, 需要在派生类的构造函数的成员初始化表中指出

```c++
class A {
	int x;
public:
	A() {x = 0;}
	A(int i) {x = i;}
}

class B:public A{
	int y;
public:
	B() {y = 0;}
	B(int i) {y = i;}
	B(int i, int j): A(i) {y = j;}
}

B b1; // 执行A::A() 和 B::B()
B b2(1); // 执行A::A() 和 B::B(int) 即默认执行基类的默认构造函数
B b3(0, 1); // 执行A::A(int) 和 B::B(int, int) 即指出了要执行非默认构造函数
```

若是拷贝构造函数, 则要在成员初始化表中同样指出

```c++
B(const B& b): A(b) {
	...
}
```

移动构造函数

```c++
B(B &&b): A(std::move(b)){	// 这里要注意右值引用b传入后就变为了左值, 所以要用move
	...
}
```

语法糖, 编译器自动在B中生成A的同参数类型的构造函数: 继承构造

```c++
class B: public A{
public:
	using A::A; // 继承 A 的所有构造函数
}
```

​**没有继承构造函数时**（传统写法）

```cpp
class A {
public:
    A() { cout << "A()" << endl; }
    A(int x) { cout << "A(int)" << endl; }
    A(int x, double y) { cout << "A(int, double)" << endl; }
};

class B : public A {
public:
    // 需要手动定义所有构造函数
    B() : A() {}
    B(int x) : A(x) {}
    B(int x, double y) : A(x, y) {}
    // ... 重复代码很多！
};
```

​**使用继承构造函数**（现代写法）

```cpp
class A {
public:
    A() { cout << "A()" << endl; }
    A(int x) { cout << "A(int)" << endl; }
    A(int x, double y) { cout << "A(int, double)" << endl; }
};

class B : public A {
public:
    using A::A;  // 一行代码搞定！
};

int main() {
    B b1;           // 调用 A()
    B b2(10);       // 调用 A(int)
    B b3(10, 3.14); // 调用 A(int, double)
}
```

使用继承构造后还是可以自定义自己的构造函数

### 虚函数

继承的一个很重要的作用就是希望使用父类的指针指向子类, 方便实现多态

问题: a, b是什么类型时, a = b 是合法的

- **类型相容的, 可以赋值**
- 赋值相容, 不一定类型相容(例如数据转换, 类型不相容, 通常会导致窄化)

```c++
class B: public A;
A a; 
B b;
a = b;
```

 **对象切片:**  a和b都是栈上的对象, `a=b`​则将栈上`b`​的内存拷贝到`a`

- 但有个严重的问题, `a`​和`b`不一样大
- 赋值后对象的身份发生变化, 从原来的派生类变为了基类
- 属于派生类的属性已不存在, 因为基类A中本来就没有这些派生类属性
- 所以只需要拷贝属于A的部分内存即可, 这就是对象切片
- 相当于执行了一下A的拷贝构造函数, 在编译器生成的时候就生成好了, 需要拷贝A的那些成员

C++的函数绑定机制: 如何知道该执行哪一个函数

1. 前期绑定

    1. 编译时刻
    2. 依据对象的静态类型
    3. 效率高但灵活性差
2. 动态绑定

    1. 运行时刻
    2. 依据对象的实际类型
    3. 灵活性高, 效率低

对于注重效率的C++, 默认使用前期绑定, 动态绑定需要显式指出 (**区别于默认动态绑定的Java**)

- 声明某个函数为多态函数 `virtual`关键字即显式指出需要动态绑定

#### virtual

如基类中被定义为虚成员函数, 则派生类对其重定义的成员函数均为虚函数

限制

- 类的成员函数才可以是虚函数
- 静态成员函数不能是虚函数
- 内联成员函数不能是虚函数
- 构造函数不能是虚函数
- 析构函数可以(往往)被声明为虚函数

虚函数就是多态函数

但为什么虚函数能实现多态呢

- 对象的内存空间中增加一个虚表指针, 指向其虚函数表: 位于对象内存空间的最上方

​**编译时（静态绑定阶段）** ：

1. 检查 `ptr`​ 的​**静态类型**（Base*）
2. 在 Base 类中查找 `func` 这个名字
3. 如果找到，检查访问权限、参数匹配等
4. ​**如果是非虚函数**：生成直接调用 Base::func 的代码
5. ​**如果是虚函数**：生成通过虚表(vtable)间接调用的代码

​**运行时（动态绑定阶段 - 仅虚函数）** ：

1. 获取 `ptr` 实际指向的对象的虚表指针
2. 从虚表中找到正确的函数地址
3. 跳转到该地址执行

**直到构造函数返回后, 对象才可以正常使用**

- 当在执行基类构造函数的时候, 使用的虚函数都是基类的函数, 此时禁止虚函数机制
- **类型转换的时间线**：

1. ​**内存分配**：分配原始内存，对象没有类型
2. ​**Base 构造函数开始**​：对象类型 = `Base`
3. ​**Base 构造函数结束**​：对象部分类型 = `Base`
4. ​**Derived 构造函数开始**​：对象类型**开始转换**
5. **Derived 构造函数结束**：对象类型 = `Derived`（完整类型）

- 虚表指针是在构造函数的执行过程中被逐步设置的

尽量在虚函数重写的时候加上`override`关键字, 可以帮助程序员进行检查, 因为编译器会严格匹配是否重写了基类中的虚函数

### final和override

​`final`表示该方法不能再被重写

​`override`用于编译器进行检查, 是否正确重写了基类中的虚函数

### 虚函数中可能会出现的访问控制问题

本质是因为**访问控制检查发生在编译时，基于静态类型**

```cpp
struct B { 
protected: 
    virtual void f() {} 
};
struct D : B {
public:
    void f() override {}  // 放宽为 public
};

int main() {
    D d;
    d.f();     // 直接调用, 是静态绑定, 检查D::f, 是public
    B* pb = &d;
    pb->f();   // 是虚函数, 动态绑定, 但编译器进行静态检查, 检查B::f, 是protected 报错
}
```

### 纯虚函数

声明时在函数原型后面加上`=0`: 意思是"not there"

往往只给出函数声明, 不给出实现

- 可以给出实现
- 让派生类可以使用基类的实现
- 纯虚函数只是要求, 派生类必须要重定义给出实现, 但是可以复用基类的实现的

```cpp
#include <iostream>
#include <string>
using namespace std;

class Animal {
protected:
    string name;
public:
    Animal(const string& n) : name(n) {}
    
    // 纯虚函数，但提供实现
    virtual void speak() const = 0;
    
    virtual ~Animal() = default;
};

// 纯虚函数的实现
void Animal::speak() const {
    cout << "I am an animal named " << name << endl;
}

class Dog : public Animal {
public:
    Dog(const string& n) : Animal(n) {}
    
    void speak() const override {
        // 调用基类的实现，然后添加狗特有的行为
        Animal::speak();  // 使用基类的实现
        cout << "Woof! Woof!" << endl;
    }
};

class Cat : public Animal {
public:
    Cat(const string& n) : Animal(n) {}
    
    void speak() const override {
        // 完全重写，不使用基类实现
        cout << name << " says: Meow!" << endl;
    }
};

class Parrot : public Animal {
public:
    Parrot(const string& n) : Animal(n) {}
    
    // 使用基类的默认实现，但必须显式声明
    void speak() const override {
        Animal::speak();  // 直接调用基类实现
    }
};

int main() {
    Dog dog("Buddy");
    Cat cat("Whiskers");
    
    dog.speak();
    cout << "---" << endl;
    cat.speak();
    
    // Animal a("Generic");  // ❌ 错误：不能创建抽象类的对象
}
```

如果一个类中有一个以上的纯虚函数, 则该类为**抽象类**

- 不能用于创建对象
- 为派生类提供框架, 派生类提供抽象基类的所有成员函数的实现
- 只能声明为指针或引用, 作为基类指针来指向派生类

### 抽象工厂模式

### 析构函数往往声明为虚函数

虚析构函数: 确保对于基类指针调用`delete`的时候, 能正确绑定到派生类的析构函数

### 绝对不要重新定义继承而来的默认参数值

- **缺省参数是静态绑定**：在编译时确定

- ​**虚函数是动态绑定**：在运行时确定
- ​**两者不同步**：导致混乱行为

```cpp
#include <iostream>
using namespace std;

class Shape {
public:
    virtual void draw(int color = 1) const {
        cout << "Shape::draw with color = " << color << endl;
    }
};

class Circle : public Shape {
public:
    // 重新定义了缺省参数值！
    virtual void draw(int color = 2) const override {
        cout << "Circle::draw with color = " << color << endl;
    }
};

int main() {
    Circle circle;
    Shape* pShape = &circle;  // 基类指针指向派生类对象
    
    pShape->draw();  // 猜猜输出什么？
    // 你期望：Circle::draw with color = 2
    // 实际：Circle::draw with color = 1
}
```

编译器视角: 编译器处理 pShape->draw() 时：

1. 检查 `pShape`​ 的静态类型：`Shape*`
2. 查找 `Shape::draw` 的签名，包括缺省参数
3. 发现缺省参数是`1`
4. 编译为：`pShape->draw(1)`
5. 运行时通过虚表调用 `Circle::draw(1)`

对象中只记录了虚函数的入口地址

## 多继承

### 虚继承

菱形继承问题:

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    int age;
    void breathe() { cout << "Animal breathes" << endl; }
};

class Mammal : public Animal {
public:
    void feedMilk() { cout << "Mammal feeds milk" << endl; }
};

class Bird : public Animal {
public:
    void fly() { cout << "Bird flies" << endl; }
};

// 多继承：Bat 同时继承 Mammal 和 Bird
class Bat : public Mammal, public Bird {
public:
    void echolocate() { cout << "Bat uses echolocation" << endl; }
};

int main() {
    Bat bat;
    
    // ❌ 问题1：二义性 - 不知道访问哪个 age
    // bat.age = 10;  // 编译错误：对成员'age'的请求不明确
    
    // ❌ 问题2：二义性 - 不知道调用哪个 breathe()
    // bat.breathe();  // 编译错误：对成员'breathe'的请求不明确
    
    // ✅ 需要明确指定路径
    bat.Mammal::age = 5;
    bat.Bird::age = 3;
    
    cout << "Mammal age: " << bat.Mammal::age << endl;  // 5
    cout << "Bird age: " << bat.Bird::age << endl;      // 3
    // ❌ 问题3：同一个动物有两个 age，不合理！
}
```

内存布局

```nestedtext
没有虚继承时 Bat 的内存布局：
+-------------------+
| Mammal 部分       |
|   Animal 子对象1  |  ← 第一个 Animal 实例
|     int age       |
+-------------------+
| Bird 部分         |
|   Animal 子对象2  |  ← 第二个 Animal 实例
|     int age       |
+-------------------+
| Bat 自己的成员    |
+-------------------+

Animal 在内存中有两个副本！
```

解决方案, 虚继承

```cpp
class Animal {
public:
    int age;
    void breathe() { cout << "Animal breathes" << endl; }
};

// 使用虚继承
class Mammal : virtual public Animal {  // 关键：virtual
public:
    void feedMilk() { cout << "Mammal feeds milk" << endl; }
};

class Bird : virtual public Animal {  // 关键：virtual
public:
    void fly() { cout << "Bird flies" << endl; }
};

// 现在 Bat 正常继承
class Bat : public Mammal, public Bird {
public:
    void echolocate() { cout << "Bat uses echolocation" << endl; }
};

int main() {
    Bat bat;
    
    // ✅ 问题解决：没有二义性
    bat.age = 10;        // 可以访问
    bat.breathe();       // 可以调用
    
    // ✅ 只有一个 age
    bat.Mammal::age = 5;
    cout << bat.Bird::age << endl;  // 输出 5，是同一个 age！
    
    bat.feedMilk();
    bat.fly();
    bat.echolocate();
}
```

虚继承的内存布局

```text
使用虚继承后 Bat 的内存布局：
+-------------------+
| Mammal 部分       |
|   vptr (虚基类表指针) |
+-------------------+
| Bird 部分         |
|   vptr (虚基类表指针) |
+-------------------+
| Bat 自己的成员    |
+-------------------+
| Animal 部分       |  ← 只有一个共享的 Animal 实例
|   int age         |
+-------------------+

只有一个 Animal 子对象，通过虚基类表指针共享访问。
```

虚继承中构造函数的执行顺序具有特殊性

- 虚基类的构造函数由最新派生出的类的构造函数调用
- 虚基类的构造函数优先非虚基类的构造函数执行

```cpp
class Animal {
public:
    Animal() { cout << "Animal constructor" << endl; }
};

class Mammal : virtual public Animal {
public:
    Mammal() { cout << "Mammal constructor" << endl; }
};

class Bird : virtual public Animal {
public:
    Bird() { cout << "Bird constructor" << endl; }
};

class Bat : public Mammal, public Bird {
public:
    Bat() { 
        // Animal 的构造函数由 Bat 直接调用！
        cout << "Bat constructor" << endl; 
    }
};

int main() {
    cout << "Creating Bat:" << endl;
    Bat bat;
    return 0;
}

// Creating Bat:
// Animal constructor   ← 先构造虚基类
// Mammal constructor   ← 然后按继承顺序构造直接基类
// Bird constructor     ← 再构造第二个直接基类
// Bat constructor      ← 最后构造自己
```

实际上就是避免了构造直接基类 Mammal和 Bird的时候构造出两个Animal对象, 统一最先构造Animal

为什么能通过`Mammal`​和`Bird`​来访问到同样的`age`属性呢

```text
假设 Bat 对象在内存地址 0x1000：

地址      内容
0x1000: [vptr_mammal]  → 指向 Mammal 虚基类表
0x1008: [vptr_bird]    → 指向 Bird 虚基类表  
0x1010: [bat_data]
0x1018: [age = 999]    ← 这就是我们要找的！

Mammal 虚基类表在 0x2000：
0x2000: [offset = 0x18]  ← 从 Mammal 开始(0x1000)到 Animal(0x1018)的偏移

Bird 虚基类表在 0x3000：
0x3000: [offset = 0x10]  ← 从 Bird 开始(0x1008)到 Animal(0x1018)的偏移

计算过程：
1. 通过 Mammal 访问 age：
   Mammal 地址: 0x1000
   从表读取偏移: 0x18
   目标地址: 0x1000 + 0x18 = 0x1018 ✓

2. 通过 Bird 访问 age：
   Bird 地址: 0x1008  
   从表读取偏移: 0x10
   目标地址: 0x1008 + 0x10 = 0x1018 ✓
   
得到同一个地址！
```

​**虚继承中查找唯一成员的三个关键步骤**：

1. ​**存储偏移信息**​：每个虚继承的类都有一个**虚基类表指针**
2. ​**运行时查找**​：通过指针找到​**虚基类表**​，表中存储了到共享基类的**偏移量**
3. ​**计算地址**​：`目标地址 = 当前子对象地址 + 偏移量`
