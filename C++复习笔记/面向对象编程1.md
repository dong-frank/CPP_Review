# 面向对象编程1

C++中的**面向对象部分**

‍

## OOP OO-Programing

为什么要OOP

非OO的编码，用结构体表示，存在问题

- 存在安全隐患，可以访问到结构体中的不希望被访问到的变量  -> **OO的封装，提供访问控制**
- 不符合数据类型定义 *比如定义的Stack结构体，希望只能用*​*​`push和`​*​`pop`​*​`但实际可以直接访问到结构体成员`​*

为什么要提出OO

- 控制访问权限
- 将数据和行为封装到一起
- 封装的本质是隔离变化, 仅供内部推理

‍

## 如何实现的private和public

是在编译期确定的, 二进制中没有任何表示private和public的信息

- 刚开始cpp是没有编译器的, 是由Cfront将cpp转译为c程序, 再进行编译
- 面向对象的cpp实际上和不支持面向对象的c是等价的
- 只要在Cfront的转译阶段, 增加一个对于private和public的检查手段后, 通过检查即可去掉private和public

private和public是**辅助设计**的, 而非强制性的, 难以保证故意去破坏其安全性

编译时类的成员变量和成员函数是分开的, 成员函数是所有对象一起使用的, 放在代码区

​`bool Stack::push(int i)`是语法糖

```c++
bool push(Stack* const this, int i)
```

所有语言的高级机制都是编译器实现的, 编译完的二进制大家都差不多

‍

## 封装

### 类

- 成员变量
- 成员函数

先声明再使用

- ​`.h`: 类的声明, 声明所有的变量和函数
- ​`.cpp`​: 成员函数的实现 `类的前缀::函数`

*可能出现头文件多次引入的问题*

‍

函数体实际上也可以写在头文件中 **内联函数**

- 将函数体的代码直接替换为函数调用, 节省了函数调用的开销
- 但这只是一个建议, 不保证编译器永远会进行内联, 函数要足够简单编译器才会进行内联
- 常将私有成员的`get`​和`set`方法作为内联函数

创建对象的方法

1. 在`main`​函数外的全局静态区创建对象 `Tdate g`, 访问是最快的
2. 在`main`​函数内的栈上创建对象 `Tdate t`, 栈上的内存分配非常快, 最常用, 只有当栈上空间不够大时可能才需要堆上创建对象
3. 在堆上创建对象 `Tdate *p = new Tdate`, 创建对象很灵活, 但很慢

‍

### 模块

cpp的新机制, 语义级别的拷贝, 解决头文件重复引入的问题

- 模块单元`.cppm`
- 编译后输出

  - 可导入的`pcm`
  - 可链接的对象文件
- 编译过程要注意顺序, 模块存在依赖关系要按顺序编译

### 构造函数

负责完成对象的初始化

1. 为对象提供一个标识符 **有名变量**
2. 内存分配
3. 对象的数据和成员进行初始化

语法

- 与类同名, 无返回类型
- 自动调用, 不可直接调用
- 可重载
- 默认构造函数

  - 当类中未提供构造函数时, 由编译系统提供的一个无参数的构造函数
  - 若自定义了构造函数, 就**不再提供**默认构造函数了  ==任何程序员介入的行为, 编译器就不再介入==
- public

  - 也可定义为private, 由这个类内的方法接管对象创建
- =default 使用编译器的默认构造函数
- =delete 删除编译器的默认版本
- 委托构造`C():C(1){}`​: 在`C()`​这个构造函数中调用了`C(int)`来进行构造

若使用的是默认构造函数, 无法确定栈和堆中的对象的值: 默认构造函数不会给成员变量赋0之类的初始化操作

调用构造函数

```c++
A a1 = A(1); <=> A a1(1) <=> A a1 =1;
A a2 = A(); <=> A a2;
A a3 = A("abcd"); <=> A a3("abcd"); <=> A a3 = "abcd";
```

‍

### 成员初始化表

用构造函数初始化对象存在一些问题

- 有些变量无法初始化: const 和引用
- cpp中`const`要求在定义的时候初始化
- 引用要求在定义的时候初始化, 且一旦初始化后不得更改引用的指向

成员初始化表, 是对构造函数的补充

- 先于构造函数体
- ==按类数据成员声明次序进行执行: 不管初始化表中顺序是怎么样的==

```c++
class A
{
	int x;
	const int y;
	int& z;
public:
	// 执行顺序为
	// int x =0;
	// const int y =1;
	// int& z = x;
	// 是对变量定义的补充
	A(): y(1),z(x),x(0){
		x = 100;
	}
}
```

成员初始化表也减轻了编译器的负担

- 在构造函数中赋值, 相当于两次的赋值: 声明时默认初始化(1次赋值), 构造函数中的赋值(2次赋值)
- 在成员初始化表中, 只有一次赋值: 直接初始化

在后续的cpp标准中, 允许在声明中直接统一初始化, 效果和成员初始化表一致

```c++
class A
{
	int x = {1};
	const int y;
	int& z;
}
```

对象成员变量也用成员初始化表进行初始化

总结: 在构造函数中尽量使用成员初始化表来取代赋值操作

- 效率高
- 对于const 和引用成员必须使用成员初始化表
- 但数据成员太多时可以不用成员初始化表, 会降低代码可维护性

### 成员初始化

就地成员初值

```cpp
struct S{
	int x=0;
	S():x(42){}
};
```

统一初始化(花括号初始化)

```c++
int x{0};
std::vector<int> v{1, 2};
S s{1, "abc"};
```

花括号相当于循环, 等号相当于完整匹配

- 花括号对于容器, 是逐元素进行初始化
- 等号要求类型匹配

```cpp
// 花括号：列表初始化（list initialization）
int x{0};                     // 直接列表初始化
int y = {0};                  // 拷贝列表初始化

// 等号：拷贝初始化（copy initialization）
int z = 0;                    // 传统拷贝初始化
```

统一初始化还进行了窄化检查

```c++
double d = 3.14;
int a(d);	// 允许
int b = d;	// 允许
int c{d};	// 不允许, 编译会报错
```

### 析构函数

语法

- ​`~<类名>()` 析构函数只有一个无参数的版本
- 对象消亡时, 系统**自动调用**
- public

  - 可定义为private, 相当于禁止了在栈上创建对象, 因为栈上的对象是自动消亡, 但无法调用对应的析构函数, 只能通过在堆上创建, 然后手动管理

析构函数的作用

- **不是用来归还对象的内存**, 常见的误区!
- 类似Java中的`finalize()`, 恢复除了内存外的一些资源, 比如网络连接, 文件的句柄等
- 释放一些成员变量中自己申请的额外的内存, 比如成员变量为数组
- 和Java的`finalize()`的最大区别, 析构函数调用的时间是确定的, 即对象消亡的时候, 而Java是依赖GC机制

cpp中的内存回收机制 RAII: Resource Acquisition Is Initialization ==资源获取等价于对象初始化==, 对于任意的资源, 总能找到一个生命期一样的对象来管理

### 拷贝构造函数

- 创建对象时, 用同一类的对象对其初始化
- 自动调用

为什么cpp要设计拷贝构造函数

```c++
A a;		// 先创建a的内存
A b = a;	// 再创建b的内存, 再将a的内存复制进b的内存
```

- Java中创建对象时得到的变量, 都是对象的引用
- 但cpp中这样是在栈中创建的对象

如何拷贝这件事并不确定, 所以需要一个拷贝构造函数

参数

- 是同类型的一个引用, 必须是引用, 否则这个函数就是按值拷贝, 但我们现在就在定义按值拷贝
- 必须是`const`, 拷贝不会影响原始对象

```c++
A(const A& a);
```

编译器同样提供了默认拷贝构造函数

- 逐个成员初始化
- 对于对象成员, 该定义是递归的

拷贝构造函数同样也可以=delete

- 禁止该对象的按值拷贝

大部分时候不需要自定义拷贝构造函数, 那么什么时候需要

```c++
class string
{	char *p;
public:
	string(char *str) {
		p = new char[strlen(str) + 1];
		strcpy(p, str);
	}
	~string(){
		delete[] p;
	}
}

string s1("abcd");
string s2 = s1;
```

当我们不定义拷贝构造函数时, 默认的拷贝构造函数会导致**悬挂指针**

- 因为由于`char *`的拷贝是将两个指针的值相等

- 即s1和s2的p都指向同样的地址
- 这样当s1先消亡, s2再消亡, 尝试`delete[]p`时, 此时就会触发段错误

总结: 当一个对象申请了额外资源时, 可能就要考虑进行自定义拷贝构造函数, 实现**深拷贝**

同样的, ==任何程序员介入的行为, 编译器就不再介入, 若自定义了拷贝构造函数, 未说明的拷贝行为, 调用默认的构造函数==

栈上的对象是按值拷贝, 堆上的对象是按引用拷贝

- 栈上的对象通常我们希望进行深拷贝: 即按值拷贝
- 堆上的对象通常我们希望进行浅拷贝: 即按引用拷贝

‍
