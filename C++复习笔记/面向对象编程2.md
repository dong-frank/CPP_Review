# 面向对象编程2

## 移动构造函数

```c++
string generate() {
	return string("test");
}

string S = generate();
```

这里有两次的拷贝构造, 为了效率, 可以直接把"test"的内存作为S

‍

### 右值引用

- 左值: 可以在程序中通过代码访问其存储地址的对象 **有名变量**
- 等号左侧是左值, 右侧是右值
- 当右值永远无法写到等号左侧时, 称为右值引用 **比如一些字面值, 或者临时结果**

‍

#### 非常量引用可以绑定到左值

```c++
int a = 1;
int &ra = a;
```

**创建一个名为** **​`ra`​**​ **的引用，它绑定到变量** **​`a`​**​ **上**。

- ​`ra`​为非常量引用 `int&`
- ​`a`为左值变量

引用是别名

```cpp
int a = 1;
int &ra = a;  // ra 是 a 的别名

// 现在 ra 和 a 指向同一块内存
ra = 2;       // 相当于 a = 2
std::cout << a;  // 输出 2
```

内存视角

```text
内存地址: 0x1000  [1]  ← a 存储在这里
               ↓
           ra 引用指向这里

当执行 ra = 2 后：
内存地址: 0x1000  [2]  ← a 和 ra 都指向这里
```

引用vs指针

```cpp
// 引用方式
int a = 1;
int &ra = a;    // ra 是 a 的别名
ra = 2;         // 直接修改 a

// 指针方式  
int a = 1;
int *pa = &a;   // pa 指向 a 的地址
*pa = 2;        // 通过指针修改 a
```

​**关键区别**：

- 引用：语法上像变量，本质上是指针的语法糖 `T * const`
- 指针：显式存储地址，需要解引用

为什么只能绑定到左值

```cpp
int a = 1;          // a 是左值：有名称，可以取地址
int &ra = a;        // ✅ 正确：绑定到左值

int &rb = 5;        // ❌ 错误：5 是右值，没有内存地址
int &rc = a + 1;    // ❌ 错误：a+1 是临时结果，没有持久内存
```

#### 常量引用可以绑定到左值或右值

**常量引用可以绑定到临时对象（右值），并且会延长该临时对象的生命周期，使其与引用的生命周期相同**

```c++
const A &ca = getA();
```

常量引用也可以绑定到左值

```cpp
int a = 1;
const A &ca = a;
```

#### 右值引用可以绑定到右值

右值引用 `A&& ca`

右值引用可以绑定到右值, 会自动延长临时变量的生命周期

```c++
A &&aa = getA();	// 相当于直接获取的返回值的引用, 少了一次拷贝
aa.setVal(2);
```

绑定后aa相当于一个左值

右值引用主要两个用途

1. 移动构造函数
2. 模板的完美转发

右值引用和常量引用的区别

- 常量引用`const T&`​; 右值引用`T &&`
- 常量引用是只读引用, 但右值引用可以修改, 就像普通的左值一样
- 常量引用只可以调用`const`方法
- 常量引用只能复制不能移动, 而右值引用, 支持移动 (移动构造函数的参数就是右值引用)
- 能经常看到涉及容器或者字符串的函数参数中, 有一个常量引用, 因为常量引用即可以绑定左值也可以绑定右值, 同时保证了是只读的

### 移动构造函数

```c++
MyArray(MyArray &&other): size(other.size), arr(other.arr) {
	other.arr = NULL;
}
```

直接移动内存, 将原来内存设为NULL, 只涉及到指针的赋值

总结: **如果需要自定义拷贝构造函数，通常也需要自定义移动构造函数**

- 当类包含动态分配的资源时，通常需要自定义拷贝构造函数（实现深拷贝）
- 在这种情况下，自定义移动构造函数可以显著提高性能

注意区分什么是引用绑定, 什么是构造

```cpp
string generate()
{    ......
     return string("test");
}

string S=generate();  // 移动构造

const string& name = generate(); // ok 是绑定到常量引用  
string&& name = generate(); // also ok 是绑定到右值引用
```

注意右值引用绑定后就变为左值

```cpp
void process(int && r) {}   // 接受右值引用参数

void handle(int && rvalue) {
    // 变量 rvalue：
    // 1. 有名称：rvalue
    // 2. 有地址：&rvalue 是有效的
    // 3. 有标识：可以多次使用
    // 这些都是左值的特征！
    
    std::cout << &rvalue << std::endl;  // ✅ 可以取地址
    rvalue = 10;                       // ✅ 可以修改
    int copy = rvalue;                 // ✅ 可以拷贝
    
    // process(rvalue);  // ❌ 错误：rvalue 是左值，但 process 需要右值
    process(std::move(rvalue));  // ✅ 正确：转换为右值

    // 注意：rvalue 现在处于"有效但未指定状态"
    // 不应该再使用 rvalue 的值（除非重新赋值）
}
```

## 返回值优化 RVO

对于以下的代码发生了几次拷贝构造几次移动构造

```cpp
string generate()
{    ......
     return string("test");  // string("test")调用一次构造函数
							 // return 语句因为返回的是临时对象（右值），触发移动构造
							 // 从函数内的临时对象移动到函数返回值的临时存储位置
							 // 临时对象在return后销毁
}

string S=generate();  // 调用处, 由于函数返回值是右值, 触发移动构造
					  // 函数的返回值的临时存储在初始化S后消耗
```

当一个函数的返回值是没有名称的临时对象时, 编译器会直接在函数返回后的作用域中创建, 避免了第一次的拷贝/移动构造

17标准后, 第二次的移动也不会发生, 编译器会直接在需要返回值的地方构造返回对象 `直接在S的位置构造 std::string("test")` 这样就只有一次的构造, 零拷贝零移动

很多时候, 我们不会在函数的返回处直接返回临时变量, 而是返回一个局部变量, 这就涉及编译器的NRVO(命名返回值优化)

返回值优化确认一定会执行, 而命名返回值优化是推荐执行

## 动态内存

- 栈: 局部变量和按值传递变量
- 堆: 动态分配的

C++使用`new`​和`delete`​来管理堆的动态内存; 而C使用`malloc`​和`free`

### 动态对象

在堆中创建的对象

- 堆上的对象都是无名对象
- 必须通过指针来访问
- 无论对象有多大, 指针的大小都是一样的

为什么要引入`new`​和`delete`操作符?

- C++创建的对象, 不是C语言创建的结构体
- 需要构造函数和析构函数
- ​`new`​和`delete`​会分别调用构造函数和析构函数, `malloc`​和`free`不会

​`new`是可重载的

### 对象删除

```c++
delete intPtr;
intPtr = nullptr;

delete[] intArr;
```

### 动态对象数组

```c++
A *p;
p = new A[100];
delete []p;  // 这个方括号不能省
```

注意

- ~~不能显示初始化, 相应的类必须有默认构造函数~~ 98标准, 现在可以使用统一初始化 `A* p1 = new A[5]{1, 2, 3, 4, 5};`
- delete中的[]不能省

为什么不能省略`[]`

- 和归还内存无关, 归还内存由操作系统实现, 绝对不会归还错误
- 但需要调用析构函数, 数组中的每个元素都应该调用析构函数
- 如果没有`[]`​只会对这个`p`​调用`delete`​, 并不会对数组中的每个元素调用`delete`

是如何记录的需要调用多少次析构函数, 在C++中, 数组的左侧额外申请了一个size_t大小, 存放数组的大小

```cpp
// delete[] p 实际生成的伪代码：
// 1. 获取数组大小
size_t* size_ptr = reinterpret_cast<size_t*>(p) - 1;
size_t count = *size_ptr;

// 2. 逆序调用析构函数
for (size_t i = count; i > 0; --i) {
    p[i-1].~A();  // 调用每个元素的析构函数
}

// 3. 释放整个内存块（包括前面的大小信息）
operator delete[](size_ptr);
```

**因此, 若省略[], 左侧额外申请的并不会被归还, 且只会调用一次析构函数**

### 动态2D数组

先申请一个二级指针, 再每一行申请一个一级指针

实际使用中, C++都是使用一维数组来模拟多维数组, 这样只要寻址一次即可

## Const成员

**const 总是修饰它左边的东西，如果左边没有东西，就修饰右边的东西**

```c++
class A {
	const int x;
}
```

初始化放在构造函数的成员初始化表中进行, 新标准中允许就地统一初始化

### Const成员函数

编译器会禁止const 的对象调用会修改对象自身的成员函数

是如何禁止

```c++
void A::show() const {
	cout << x << y;
}
```

 通过标记const 成员函数来实现, 未被标记的成员函数就会被禁止

这个const实际修饰的是成员函数的参数, 从而在语法层面实现了检查, 未被标记const则类型不匹配自然无法调用。

且标记const的函数内部不能修改相关成员变量, 因为一旦修改就违反`const`语义而报错

```c++
void show(A* const this); // 普通版本
void show(const A* const this); // const 成员方法
```

但存在漏洞, 只要不违反语法规则都能通过, 但存在人为破坏的可能

```c++
class A
{
	int a;
	int& indirect_int;
public:
	A(): indirect_int(a){};
	void f() const{
		indirect_int ++;  // 这里通过a的引用, 来修改a, 并没有违反语法规则
						  // 相当于我不修改指针本身, 修改指针指向的内容, 是无法发现的
	}
};
```

甚至强制类型转换就能绕过

**防君子不防小人**, 是辅助你进行程序设计的, 而非为黑客设计的

如果程序设计时非得修改const变量, 可以将变量声明为 `mutable`

```c++
class Fib{
	......
	Fib(int n): n_(n) {}
	int value() const {
		if (!cached){
			cache = fib(n);
			cached = true;
		}
		return cache;
	}
	int n_;
	mutable bool cached = false;
	mutable int cache = 0;
};
```

const成员承诺不改变对象的可观察状态, 而mutable是内部实现的细节, 对外不可见

### 常量表达式

在编译器即可计算出结果的表达式

- 把计算移到编译期, 更快, 错误更早暴露
- constexpr: 可在编译期求值(也可运行期)

常用于switch-case, 由于case 中必须是常量, 通过constexpr可以把部分的函数看作常量, 只要他们是能在编译器求值的

```cpp
constexpr int bad_c();
constexpr int eof_c();
constexpr int be_c();

void f(Flags x) {
    switch (x) {
        case bad_c(): /* ... */break;
        case eof_c(): /* ... */ break;
        case be_c(): /* ... */ break;
        default: /* ... */ break;
    }
}
```

### 静态成员

类刻画了一组具有相同属性的对象

对象是类的实例

问题: 同一个类的不同对象如何共享变量

- 如果把这些共享变量定义为全局变量, 则缺乏数据保护, 且存在名污染

静态成员变量

- 类对象所共享
- 唯一拷贝
- 遵循类访问控制
- 和全局静态变量一样, 也是一进入程序就会完成初始化

静态成员如何初始化: 必须在类外进行

- 不是类的**对象**所具有的, 所以不能写在构造函数中
- 也不能就地初始化

```c++
class A
{
	int x,y;
	static int shared;
	...
};

int A::shared=0;

A a,b;
```

在旧标准中, 静态成员初始化只能放在类的实现文件中, 在新标准中, 允许在类内进行定义, 但要声明为`inline static`

```cpp
class A
{
	int x,y;
	// static int shared = 1; 报错
	inline static int shared = 1;
	...
};
```

静态成员函数 **带类的名空间的成员函数**

- 只能存取静态成员变量, 调用静态成员函数
- 遵循类访问控制

C++支持观点 "类也是对象"

- 静态成员可以通过对象使用 `A a; a.shared;`
- 也可以通过类使用 `A::shared;`
- C++的静态成员模拟了"类对象"
- C++11后类型作为一等公民

  -  **​`typeid`​**​ **运算符：获取类型信息对象**
  - ​**​`decltype`​**​ **：类型作为表达式**
- **模板元编程中的"类作为对象"**

静态成员的用处

- 记录对象的数量
- **可以通过静态成员函数来调用私有的构造函数和析构函数** 单例模式

单例模式: 体现了一种资源管理原则, 谁创建谁归还

```cpp
class singleton {
protected:
    singleton(){}
    singleton(const singleton&);
public:
    static singleton* instance() {
        return m_instance == nullptr ? m_instance = new singleton : m_instance;
    }
    static void destroy() {
        delete m_instance;
        m_instance = nullptr;
    };
private:
    static singleton* m_instance;
};

singleton* singleton::m_instance = nullptr;
```

设计模式强依赖于OO的语言机制

### 友元

类外部不能访问该类的private 成员

- 通过该类的public方法
- 会降低对private成员的访问效率, 缺乏灵活性, 每个private成员都要写一个对应的`get`​和`set`方法
- 例如: 矩阵类、向量类、全局函数, 可以在全局函数中实现矩阵和向量相乘

性能至上的C++提出友元的思想, 声明为友元的函数或类能直接访问private成员 `friend`关键词

- 提高程序设计灵活性
- 数据保护和对数据的存取效率之间的一个折中方案

友元不具有传递性: 友元的友元, 不是我的友元

友元的分类

- 友元函数
- 友元类
- 友元类成员函数

迪米特原则 **最少知识原则**

1. 避免将data member 放在公开接口中
2. 努力让接口完满且最小化

### 先声明再使用

为了解决有时候重复使用未声明的变量问题, 引入前向声明(不完整声明)

- 但前向声明无法得知内存大小
- 因此使用前向声明时必须使用引用或指针

```cpp
class Matrix
		{    ......
 		     friend void multiply(Matrix &m, Vector &v, Vector &r);
		};
class Vector
         {    ......
 	         friend void multiply(Matrix &m, Vector &v, Vector &r);
          };
// 无法编译, 因为Matrix中的友元函数有未声明的Vector, 而Vector中的友元函数又有Matrix
```

前向声明

```cpp
class Vector;

class Matrix
{
    friend void multiply(Matrix &m, Vector &v, Vector &r);
};
class Vector
{
    friend void multiply(Matrix &m, Vector &v, Vector &r);
};
```
