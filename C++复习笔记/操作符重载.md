# 操作符重载

## 多态

- 同一论域中一个元素可有多种解释
- 提高语言灵活性
- 程序设计语言

  - 一名多用: 函数重载
  - 类属: template
  - OO程序设计: 虚函数

前面两种多态发生在编译时，虚函数发生在运行时（动态绑定）

## 操作符重载

和虚函数不同, 是静态绑定的

函数重载（注意区分函数重写，即虚函数）

- 名同, 参数不同
- 静态绑定

歧义控制: 假设两个函数, 参数分别为`int`​和`double`​, 那么调用时传入`0`就不知道要调用哪个函数

- 更好匹配

操作符重载: 希望将操作符作为函数名一样重载

为什么要对操作符进行重载?

一个重要理念, **C++不区分内置类型和自定义类型**

- 那么就希望自定义类型也能像内置类型那样, 使用操作符进行计算

- 操作符重载后仍会遵循原本的四则运算定律

### 操作符重载的实现

```c++
class Complex {
	Complex operator + (Complex& x) {
		...
	}
}
```

```c++
c = a.operator + (b);
```

当程序员用`c = a + b`​时, 由于`+`​无法匹配自定义数据类型, 编译器就会调用`operator + `

操作符重载一般为成员函数, 但也可以声明为全局函数

- 成员函数编译完就是全局函数
- 是编译期确定的
- 若是全局函数, 操作符重载中的参数, 必须要有一个自定义类型, **不能对内置类型重载**
- ​`new`​和`delete`除外, 可以对内置类型重载: 重载分配内存的地方

不可重载的操作符

- ​`.`​  `.*`​  `::`​  `?:`

- 直接访问操作符`.`: 一旦重载就断绝了编译器的直接访问成员的方法

- 成员解引用访问操作符`.*`: 和直接访问操作符类似的原因
- 名空间限定操作符`::`: 类似
- 三元操作符`?:`​: 是唯一的三目操作符, 实质是if-else语句, 如果被重载, 按照参数去执行的话, 破坏了原先的if-else只会执行一条路径的逻辑 **短路原则**
- 其他的写不出来的操作符, 也不能被重载, 比如`sizeof`​ 和`typeof`

对于全局函数操作符有一些限制

- ​`=`​  `()`​  `[]`​  `->` 不能作为全局函数重载
- 后三个对参数的顺序有严格要求 `a[10]`​而不能写为`10[a]`
- 只有在成员函数中, 才能确保这个顺序: 第一个参数为`T* const this`
- 第一个赋值操作符, 编译器会在成员函数中自动重载一个, 那么这个全局函数就永远用不到(永远匹配不到它，类似名掩盖了）, 因此禁止其在全局函数重载

全局函数可以作为补充

双目操作符, 由于交换律（要支持`a+b = b+a`）, 最好在全局函数重载, 通过声明为友元函数

单目操作符, 最好在成员函数重载

没事不要重载`&&`​ 和`||`

- 会破坏短路原则
- 因为函数调用时, 会先计算所有的参数的值, 和之前提到的三元操作符类似
- 但C++的标准库中本身需要重载, 如sql库和ast库, 所以没有禁止这些操作符的重载

操作符重载中比较麻烦的一点

- 函数签名往往是固定的, 且需要记忆
- 你只可以重载实现部分

做四则运算的时候, 只能按值返回, 不能加引用：这些运算符通常返回的是一个新的对象

**尽可能让事情有效率, 但不是过度有效率**

​`a++`​ VS `++a`

- a++ 返回的是右值，得到的是未+1的`a`的临时变量
- ++a 返回的是左值，得到的是+1后的`a`

```c++
Counter& operator ++(){	// ++a
	value++;
	return *this;
}

Counter operator ++(int){ // a++ 这里的int为哑元参数, 只作为区分前缀和后缀
	Counter temp = *this;
	value++;
	return temp;
}
```

前置++ 往往比 后缀++ 效率高

- 省略了这个赋值过程

- 特别是`iterator`

## 特殊操作符重载

#### 赋值操作符`=`

- 编译器会提供默认的赋值操作符重载函数

  - 逐个成员赋值
  - 对含有对象成员的类, 该定义是递归的

```c++
A a, b;
b = a; // 调用的就是赋值操作符重载函数
```

```c++
A a;
A b = a; // 调用的是拷贝构造函数
```

编译器默认提供的赋值操作符重载函数和拷贝构造函数类似的

**五三原则：** C++11后从三原则扩充为五原则

​**三原则的核心思想**：

- 如果你定义了**析构函数、拷贝构造函数或拷贝赋值操作符**中的任何一个
- 那么你通常需要定义**全部三个**
- 因为它们共同管理相同的资源

**五原则的扩充**：

- 如果定义了**任何一个**拷贝/移动/析构函数，编译器不会自动生成**移动操作**
- 如果定义了**移动操作**，编译器不会自动生成**拷贝操作**

​**五原则的核心思想**：

> 如果你手动管理任何资源，应该显式定义全部五个特殊成员函数，以确保资源的正确管理。

赋值操作符重载不能被继承

- 继承来的基类的赋值操作符，也只能处理基类中的部分成员
- 无法处理派生类新增的对象
- 防止出现对象切片

返回值

- 默认返回的是`*this`
- 为了支持 `a=b=c`的链式赋值
- 最好不要返回`const A&`​, 由于 `(b = c).f()`

什么时候需要自定义赋值操作符重载

- 和需要自定义拷贝构造函数的理由一样，遵循五三原则

自我赋值

- 虽然能避免写出`s=s`这样的代码
- 但无法避免在函数调用的时候出现
- 需要进行证同测试`Object identity`

```cpp
    MyString& operator=(const MyString& other) {
        // 1. 检查自我赋值
        if (this == &other) {
            cout << "自我赋值，直接返回" << endl;
            return *this;
        }
        
        // 2. 释放原有资源
        delete[] data;
        
        // 3. 分配新资源
        length = other.length;
        data = new char[length + 1];
        
        // 4. 复制数据
        strcpy(data, other.data);
        
        cout << "赋值操作: " << data << endl;
        return *this;  // 返回当前对象的引用
    }
```

移动赋值操作符重载

#### 下标操作符 []

当类中封装了一个数组对象时, 可以简化访问数组的方式

```c++
char & operator [](int i) const {
	return p[i];
}
```

这里的const可以加, 但无法起到限制语义的作用, 因为返回引用后可以轻易被修改

最好的实现方式是实现两个下标操作符重载：分别对应只用下标访问，和用下标修改的场景

```c++
char & operator [](int i);			// 针对返回左值的版本
const char operator [](int i) const;// 返回右值的版本
```

看上去这两个函数的参数列表不一样, 实际是不同的, 区别在于隐藏参数`this`有无const修饰

#### 多维数组

用一维数组来模拟多维数组

引入代理类, 方便对内置类型进行操作符重载

- 代理类作为内部类
- 只是对内置类型的一个包装

```cpp
class Array2D {
private:
    int *p;
    int num1, num2;
public:
    class Array1D {
    private:
        int *p;
    public:
        Array1D(int *p) {
            this->p = p;
        }
        int &operator[](int index) {
            return p[index];
        }
        const int operator[](int index) const{
            return p[index];
        }
    };

    Array2D(int n1, int n2): num1(n1), num2(n2) {
        p = new int[n1 * n2];
    }
    virtual ~Array2D(){
        delete []p;
    }
    Array1D operator[](int index) {
        return p+index*num2;
    }
    const Array1D operator[](int index) const {
        return p+index*num2;
    }
};
```

#### () 操作符

有三种语义

1. 函数调用
2. 类型转换
3. 优先级: 不是操作数, 不可重载

#### 函数调用操作符 ()

让一个对象可以当作函数来调用: 函数对象

- 支持函数式编程

为什么用函数对象来取代函数指针

- 函数指针无法保存状态
- 函数指针编译器无法内联优化
- 函数对象是可以携带成员变量的(状态)
- 是类, 编译器可以内联优化, 执行效率高

```cpp
double operator() (double, int, int);
```

然后就可以像函数调用那样使用函数对象

```cpp
Func f;
f(2.4, 0, 8);
```

Lambda函数

- 是一个匿名的函数对象
- 是创建函数对象的语法糖
- 方括号内理解为这个函数对象的**成员变量**
- 编译器自动生成一个匿名函数对象类

Lambda捕获

- ​`[]`不捕获
- ​`[&]`以引用捕获作用域内的所有变量
- ​`[=]`以值拷贝捕获作用域内的所有变量

```cpp
bool cmpInt(int a, int b) {return a < b;}
bool (*f)(int, int) = [](int a, int b) {return a < b;}
class CmpInt{
	bool operator()(int a, int b) const{
		return a < b;
	}
};
CmpInt cmp;
```

#### 类型转换运算符

为了和函数调用操作符区分, 类型转换运算符重载时不写返回值类型

```c++
operator double() {
	return (double) n/d;
}
```

为什么要重载类型转换运算符

- 可以减少混合计算中, 需要重载的操作符函数数量

该转成int 还是 double 的问题

```c++
class A {
public:
	operator int() {return 1;}
	operator double() {return 2.0;}
};
A a;
cout << a + 0;
```

若有多种转换是同样的优先级, 编译器会报错

需要用`explicit`显式声明默认的类型转换

#### 箭头操作符(间接成员访问操作符)

​`->`​为二元运算符: `a -> b` 看上去有两个操作数

- 但重载时按一元操作符重载描述

直接成员访问操作符是不能被重载的, 但这个箭头可以

```c++
A a;
a->f();
a.operator->(f); 那么这个f的类型是什么??? 可能是成员变量, 也可能是成员方法, 各种类型都可能
```

无法确定`f`的类型, 所以重载这个要按照一元操作符重载

继续展开为`a.operator -> () -> f()`

只要规定第一个箭头的那个重载, 返回一个指针类型, 第二个箭头就自然成立

**实质目的就是将一个对象转化为指针**

```cpp
Step 1: a->f()
Step 2: 发现 a 是类类型，不是指针
Step 3: 查找 a.operator->()
Step 4: 调用 a.operator->()，得到返回值 ptr（假设是 B*）
Step 5: 对 ptr 使用内置的 -> 运算符：ptr->f()
Step 6: 执行成员访问
```

但是必须返回指针类型吗

- 还可以返回其他**已经重载过箭头操作符**的类型

箭头操作符有什么用呢, 为什么要重载, 从定义来看是硬加上的

- 简化代码, 不用再一长串的`.`​和`->`
- **避免内存泄漏 RAII**

```c++
class AWrapper {
	A* p;
public:
	AWrapper(A *p) {this->p = p;}
	~AWrapper() {delete p;}
};
```

我们通过`AWrapper`​来封装这个指针, 就可以避免不知道要在哪里去`delete`的问题

所以我们这里可以重载`AWrapper`​的箭头操作符, 来避免用`p.p->f()`这样比较麻烦的代码

```c++
A* operator->(){return p;}
```

这也就是智能指针明明是对象, 但用起来像指针的原因

C++为了支持RAII, 必须要重载箭头操作符

但也有局限性

- 即这个堆上对象, 现在和栈上对象是同生命周期了

箭头操作符重载通常应该提供两个版本

1. 被声明为`const`​成员函数, 支持对`const`变量的箭头操作
2. 非`const`成员函数

通过重载箭头操作符实现一个智能指针类

- 不只是内存泄漏问题

- 结构破碎, 有重复的清理码, 希望能直接处理

  - 使用智能指针

#### new 和 delete

频繁调用系统的存储管理, 影响效率

程序自身管理内存, 提高效率

方法

- 通过系统存储分配, 申请一块较大的内存 (系统调用)
- 针对该内存, 自己管理存储分配, 去配 (`new`​和`delete`)
- 通过重载 `new`​与`delete`实现
- 重载的`new`​和`delete`是静态成员
- 遵循类的访问控制, 可继承

这个`new`​和数组的`new[]` 不是同一个操作符, delete也是

#### 重载new

```c++
void* operator new (size_t size, ...);
```

第一个参数`size_t`​必须有, 系统自动计算对象大小, 并传给`size`

如果重载了new, 那么通过new动态创建该类的对象时, 将不再调用内置的new

​`new`的重载可以有多个

一些标准版本的`new`

```c++
/**
* 标准版本的operator new
*/
void* operator new(size_t) throw(bad_alloc);

/**
* 定位new
* 不重新分配内存, 直接调用构造函数在已有内存地址上构造对象
* 如果传入的是栈上地址, 还可以实现在栈上动态创建对象
* 还可以显式调用构造函数
*/
void* operator new(size_t, void*)throw();

/**
* 不抛异常的new
* 如果失败, 返回nullptr
*/
void* operator new(size_t, const nothrow_t&) throw();
```

重载delete, delete的重载只能有一个

```cpp
void operator delete(void *p, size_t size);
```

- 第一个参数: `void*` 被撤销对象的地址
- 第二个参数: 可有可无, 如果有, 则必须是`size_t`类型, 被撤销对象的大小
